.TH "robin_hood" 3 "Tue Apr 20 2021" "Version 2.0" "LRez" \" -*- nroff -*-
.ad l
.nh
.SH NAME
robin_hood
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBdetail\fP"
.br
.ti -1c
.RI " \fBROBIN_HOOD_STD\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBhash\fP"
.br
.ti -1c
.RI "struct \fBhash< std::string >\fP"
.br
.ti -1c
.RI "struct \fBhash< T * >\fP"
.br
.ti -1c
.RI "struct \fBis_transparent_tag\fP"
.br
.ti -1c
.RI "struct \fBpair\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_flat_map\fP = \fBdetail::Table\fP< true, MaxLoadFactor100, Key, T, Hash, KeyEqual >"
.br
.ti -1c
.RI "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_node_map\fP = \fBdetail::Table\fP< false, MaxLoadFactor100, Key, T, Hash, KeyEqual >"
.br
.ti -1c
.RI "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_map\fP = \fBdetail::Table\fP< sizeof(\fBrobin_hood::pair\fP< Key, T >)<=sizeof(size_t) *6 &&std::is_nothrow_move_constructible< \fBrobin_hood::pair\fP< Key, T > >::value &&std::is_nothrow_move_assignable< \fBrobin_hood::pair\fP< Key, T > >::value, MaxLoadFactor100, Key, T, Hash, KeyEqual >"
.br
.ti -1c
.RI "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_flat_set\fP = \fBdetail::Table\fP< true, MaxLoadFactor100, Key, void, Hash, KeyEqual >"
.br
.ti -1c
.RI "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_node_set\fP = \fBdetail::Table\fP< false, MaxLoadFactor100, Key, void, Hash, KeyEqual >"
.br
.ti -1c
.RI "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBunordered_set\fP = \fBdetail::Table\fP< sizeof(Key)<=sizeof(size_t) *6 &&std::is_nothrow_move_constructible< Key >::value &&std::is_nothrow_move_assignable< Key >::value, MaxLoadFactor100, Key, void, Hash, KeyEqual >"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename A , typename B > void \fBswap\fP (\fBpair\fP< A, B > &a, \fBpair\fP< A, B > &b) noexcept(noexcept(std::declval< \fBpair\fP< A, B > & >()\&.swap(std::declval< \fBpair\fP< A, B > & >())))"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator==\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y)"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator!=\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y)"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator<\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y) noexcept(noexcept(std::declval< A const & >()< std::declval< A const & >()) &&noexcept(std::declval< B const & >()< std::declval< B const & >()))"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator>\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y)"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator<=\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y)"
.br
.ti -1c
.RI "template<typename A , typename B > constexpr bool \fBoperator>=\fP (\fBpair\fP< A, B > const &x, \fBpair\fP< A, B > const &y)"
.br
.ti -1c
.RI "size_t \fBhash_int\fP (uint64_t obj) noexcept"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (bool)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (char)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (signed char)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (unsigned char)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (char16_t)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (char32_t)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (wchar_t)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (short)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (unsigned short)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (int)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (unsigned int)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (long)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (long long)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (unsigned long)"
.br
.ti -1c
.RI "\fBROBIN_HOOD_HASH_INT\fP (unsigned long long)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_flat_map\fP = typedef \fBdetail::Table\fP<true, MaxLoadFactor100, Key, T, Hash, KeyEqual>"

.PP
Definition at line 2252 of file robin_hood\&.h\&.
.SS "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_flat_set\fP = typedef \fBdetail::Table\fP<true, MaxLoadFactor100, Key, void, Hash, KeyEqual>"

.PP
Definition at line 2270 of file robin_hood\&.h\&.
.SS "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_map\fP = typedef \fBdetail::Table\fP<sizeof(\fBrobin_hood::pair\fP<Key, T>) <= sizeof(size_t) * 6 && std::is_nothrow_move_constructible<\fBrobin_hood::pair\fP<Key, T> >::value && std::is_nothrow_move_assignable<\fBrobin_hood::pair\fP<Key, T> >::value, MaxLoadFactor100, Key, T, Hash, KeyEqual>"

.PP
Definition at line 2264 of file robin_hood\&.h\&.
.SS "template<typename Key , typename T , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_node_map\fP = typedef \fBdetail::Table\fP<false, MaxLoadFactor100, Key, T, Hash, KeyEqual>"

.PP
Definition at line 2256 of file robin_hood\&.h\&.
.SS "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_node_set\fP = typedef \fBdetail::Table\fP<false, MaxLoadFactor100, Key, void, Hash, KeyEqual>"

.PP
Definition at line 2274 of file robin_hood\&.h\&.
.SS "template<typename Key , typename Hash  = hash<Key>, typename KeyEqual  = std::equal_to<Key>, size_t MaxLoadFactor100 = 80> using \fBrobin_hood::unordered_set\fP = typedef \fBdetail::Table\fP<sizeof(Key) <= sizeof(size_t) * 6 && std::is_nothrow_move_constructible<Key>::value && std::is_nothrow_move_assignable<Key>::value, MaxLoadFactor100, Key, void, Hash, KeyEqual>"

.PP
Definition at line 2281 of file robin_hood\&.h\&.
.SH "Function Documentation"
.PP 
.SS "size_t robin_hood::hash_int (uint64_t obj)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Definition at line 745 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator!= (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 667 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator< (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definition at line 671 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator<= (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 681 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator== (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 663 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator> (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 677 of file robin_hood\&.h\&.
.SS "template<typename A , typename B > constexpr bool robin_hood::operator>= (\fBpair\fP< A, B > const & x, \fBpair\fP< A, B > const & y)\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definition at line 685 of file robin_hood\&.h\&.
.SS "robin_hood::ROBIN_HOOD_HASH_INT (bool)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (char)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (char16_t)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (char32_t)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (int)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (long long)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (long)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (short)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (signed char)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (unsigned char)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (unsigned int)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (unsigned long long)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (unsigned long)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (unsigned short)"

.SS "robin_hood::ROBIN_HOOD_HASH_INT (wchar_t)"

.SS "template<typename A , typename B > void robin_hood::swap (\fBpair\fP< A, B > & a, \fBpair\fP< A, B > & b)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Definition at line 657 of file robin_hood\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for LRez from the source code\&.
